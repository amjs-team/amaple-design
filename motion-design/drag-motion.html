<div id="app">
    <drag-motion :ondrag="update" :onstart="startMotion" :onend="endMotion">
        <div>Drag motion</div>
    </drag-motion>
</div>

<script>
    new am.Module (document.querySelector("#app"), {
        init () {
            return {

                // el：当前拖动的DOM
                // options：移动相关的参数对象，对象属性如下：
                // keyCode：键盘按下的键值，与event的keyCode对应
                // event：原生的MouseEvent对象
                startMotion (el, { keyCode, event }) {

                },

                // options：拖动过程中增加的移动相关参数，如下：
                //  moveX：相对上一次触发此移动事件，X轴移动的距离，单位为px
                //  moveY：相对上一次触发此移动事件，Y轴移动的距离，单位为px
                //  totalX：相对触发onstart事件，X轴移动的距离，单位为px
                //  totalY：相对触发onstart事件，Y轴移动的距离，单位为px
                /////////////////////////////
                //  如果是以handleUpdate触发的调用，则没有event参数
                update (el, { moveX, moveY, totalX, totalY, keyCode, event }) {
                    el.style.left = el.offsetLeft + moveX + "px";
                    el.style.top = el.offsetTop + moveY + "px";
                },

                // options：拖动结束事件增加的移动相关参数，如下：
                // unitXTime：根据最后一次触发ondrag事件到触发onend事件X轴移动的位置作为参考，移动100px所需消耗的毫秒数
                // unitYTime：根据最后一次触发ondrag事件到触发onend事件Y轴移动的位置作为参考，移动100px所需消耗的毫秒数
                // lastMoveX和lastMoveY为拖动结束后最后一帧的移动的距离，这一般用于判断是否继续执行动画到终点还是回到起点，也可以用于在拖动结束后的惯性过渡起始速度
                // handleUpdate：可用于在结束拖动后，继续以一定轨迹执行update函数，每调用一次则相当于调用update一次，所以它一般是以setTimeout或requestAnimationFrame循环调用。参数为每一帧移动的X/Y轴速，相对于update函数中的moveX，moveY。
                endMotion (el, { moveX, moveY, totalX, totalY, lastMoveX, lastMoveY, keyCode, event }, handleUpdate) {

                    // 继续以每30毫秒的频率调用update函数
                    // 也可用第三方带有状态动画的库进行调用
                    setTimeout (() => {
                        handleUpdate (lastMoveX, lastMoveY);
                    }, 30);
                }
            }
        }
    });
</script>